import sys
import argparse
import numpy as np
import keras
import random
import gym

ACTION_SPACE = 4

class Imitation():
    def __init__(self, model_config_path, expert_weights_path):
        # Load the expert model.
        with open(model_config_path, 'r') as f:
            self.expert = keras.models.model_from_json(f.read())
        self.expert.load_weights(expert_weights_path)

        # Arguments are required for compilation, but not used for expert
        # self.expert.compile(optimizer='Adam', loss='categorical_crossentropy') 
        
        # Initialize the cloned model (to be trained).
        with open(model_config_path, 'r') as f:
            self.model = keras.models.model_from_json(f.read())

        # TODO: Delete once done troubleshooting, weights appear to be correct
        # print(self.model.get_weights())

        # TODO: Define any training operations and optimizers here, initialize
        #       your variables, or alternatively compile your model here.

        # TODO: Arguments specified in pdf.  There are multiple crossentropy functions in Keras, however
        self.model.compile(optimizer='Adam', loss='categorical_crossentropy', metrics=['categorical_accuracy']) 

        # TODO: Delete this once no longer in use, taken from env.reset()
        # test_state = np.array([[0.0061801, 0.93431817, 0.62596564, -0.41969598, -0.00715443, -0.1417985, 0.0, 0.0]])
        # print(test_state.shape)
        # print(self.model.predict(x=test_state, verbose=1))
        # raw_input()


    def run_expert(self, env, render=False):
        # Generates an episode by running the expert policy on the given env.
        return Imitation.generate_episode(self.expert, env, render)

    def run_model(self, env, render=False):
        # Generates an episode by running the cloned policy on the given env.
        return Imitation.generate_episode(self.model, env, render)

    @staticmethod
    def generate_episode(model, env, render=False):
        # Generates an episode by running the given model on the given env.
        # Returns:
        # - a list of states, indexed by time step
        # - a list of actions, indexed by time step
        # - a list of rewards, indexed by time step
        # TODO: Implement this method.

        # states = []
        # actions = []
        # rewards = []
        # num_episodes = 10  # TODO: 10, 50, and 100 episodes

        # for episode in range(num_episodes):

    	# TODO: Create first index by episode?  Seems reasonable
    	e_states = []
    	e_actions = []
    	e_rewards = []

    	done = False
    	state = env.reset()  # Restart the environment
    	while not done:  
    		e_states.append(state)  # TODO: Should this be done before or after reshape?
    		state = np.array([state])
    		model_output = model.predict(x = state, verbose = 0)  # Get action from model
    		action = np.argmax(model_output)  # Equivalent to greedy policy
    		action_vec = np.zeros(ACTION_SPACE)
    		action_vec[action] = 1
    		e_actions.append(action_vec)
    		state, reward, done, info = env.step(action)
    		e_rewards.append(reward)
    		if render:
    			env.render()

        	# # Add episode to list
        	# states.append(e_states)
        	# actions.append(e_actions)
        	# rewards.append(e_rewards)

        return np.array(e_states), np.array(e_actions), np.array(e_rewards)
        # return states, actions, rewards
    
    def train(self, env, num_episodes=100, num_epochs=50, render=False):
        # Trains the model on training data generated by the expert policy.
        # Args:
        # - env: The environment to run the expert policy on. 
        # - num_episodes: # episodes to be generated by the expert.
        # - num_epochs: # epochs to train on the data generated by the expert.
        # - render: Whether to render the environment.
        # Returns the final loss and accuracy.
        # TODO: Implement this method. It may be helpful to call the class
        #       method run_expert() to generate training data.
        
        # TODO: Remove this once implemented
        loss = 0
        acc = 0

        # TODO: Add if statement to make loading a possibility
        self.expert_states = []
        self.expert_actions = []
        self.expert_rewards = []
        for episode in range(num_episodes):
        	episode_states, episode_actions, episode_rewards \
        	= self.run_expert(env, render)

        	self.expert_states.append(np.array(episode_states))
        	self.expert_actions.append(np.array(episode_actions))
        	self.expert_rewards.append(np.array(episode_rewards))

        # TODO: Determine how to generalize to multiple episodes
        # Code above here works for 1 episode, multiple epochs, if jump to fit statement

        # self.expert_states = np.array([self.expert_states])
        # self.expert_actions = np.array([self.expert_actions])

        # self.expert_states = np.reshape(self.expert_states, (-1, 1))
        # self.expert_states = np.array([self.expert_states])
        # self.expert_actions = np.reshape(self.expert_actions, (-1, 1))
        # self.expert_rewards = np.reshape(self.expert_rewards, (-1, 1))

        # print(self.expert_states.shape)
        # raw_input()

        # TODO: hyperparameters as follows:
        # batch_size = 32 (batch gradient descent)
        # learning rate = ?? Keras wassup man?
        self.model.fit(x=self.expert_states, y=self.expert_actions, epochs=num_epochs, verbose=1, batch_size=32)

        eval_states, eval_actions, eval_rewards = self.run_expert(env, render=False)

        loss, acc = self.model.evaluate(x=eval_states, y=eval_actions, verbose=1)
        print("{} are {}, {}".format(self.model.metrics_names, loss, acc))

        return loss, acc


def parse_arguments():
    # Command-line flags are defined here.
    parser = argparse.ArgumentParser()
    parser.add_argument('--model-config-path', dest='model_config_path',
                        type=str, default='LunarLander-v2-config.json',
                        help="Path to the model config file.")
    parser.add_argument('--expert-weights-path', dest='expert_weights_path',
                        type=str, default='LunarLander-v2-weights.h5',
                        help="Path to the expert weights file.")

    # https://stackoverflow.com/questions/15008758/parsing-boolean-values-with-argparse
    parser_group = parser.add_mutually_exclusive_group(required=False)
    parser_group.add_argument('--render', dest='render',
                              action='store_true',
                              help="Whether to render the environment.")
    parser_group.add_argument('--no-render', dest='render',
                              action='store_false',
                              help="Whether to render the environment.")
    parser.set_defaults(render=False)

    return parser.parse_args()


def main(args):
    # Parse command-line arguments.
    args = parse_arguments()
    model_config_path = args.model_config_path
    expert_weights_path = args.expert_weights_path
    render = args.render
    
    # Create the environment.
    env = gym.make('LunarLander-v2')
    
    # TODO: Train cloned models using imitation learning, and record their
    #       performance.
    imitation = Imitation(model_config_path, expert_weights_path)
    loss, acc = imitation.train(env, num_episodes=1, num_epochs=50, render=render)
    # states, actions, rewards = imitation.run_expert(env, render) # imitation.generate_episode(imitation.expert, env, render)

    # TODO: Delete this for submission.  Toggle to check that model crashes w/o training
    # states, actions, rewards = imitation.generate_episode(imitation.model, env, render)
    # print(rewards)
    # raw_input("Did it crash? (ends in -100)")



if __name__ == '__main__':
  main(sys.argv)
